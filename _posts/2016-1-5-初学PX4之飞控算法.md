---
layout: post
title:  "初学PX4之飞控算法"
categories: "drons_lifes"
author: 吴兴章
tags: 工作生活
donate: true
comments: true
---
学习应用程序就回到主线程上来了，这也是我研究px4的初衷，学习姿态估计与控制算法。    

<br>
####脚本分析
下面看下重要的一个[脚本](https://github.com/PX4/Firmware/blob/master/ROMFS/px4fmu_common/init.d/rc.mc_apps)`/etc/init.d/rc.mc_apps`，可以知道姿态估计用的是attitude_estimator_q和position_estimator_inav，用户也可以选择local_position_estimator、ekf2，而姿态控制应用为mc_att_control和mc_pos_control。

<!--more-->

```sh
#!nsh
#
# Standard apps for multirotors:
# att & pos estimator, att & pos control.
#

# The system is defaulting to INAV_ENABLED = 1
# but users can alternatively try the EKF-based
# filter by setting INAV_ENABLED = 0
if param compare INAV_ENABLED 1
then
	attitude_estimator_q start
	position_estimator_inav start
else
	if param compare LPE_ENABLED 1
	then
		attitude_estimator_q start
		local_position_estimator start
	else
		ekf2 start
	fi
fi

if mc_att_control start
then
else
	# try the multiplatform version
	mc_att_control_m start
fi

if mc_pos_control start
then
else
	# try the multiplatform version
	mc_pos_control_m start
fi

#
# Start Land Detector
#
land_detector start multicopter

```
<br>
####学写应用程序
在这之前，我们需要对在NuttX操作系统里怎么写应用程序做一个了解，这样好为下面的算法部分应用分析打好基础。    

下面我将参考下面这个[官方教程](http://dev.px4.io/tutorial-hello-sky.html)做一个大体的概括。    

1. 首先编写简单的应用[示例程序](https://github.com/PX4/Firmware/tree/master/src/examples/px4_simple_app)。主要有三个部分：头文件、外部声明、主函数。
2. 注册应用程序到NSH并编译。添加新的一行`examples/px4_simple_app`到[Firmware/cmake/configs/nuttx_px4fmu-v2_default.cmake](https://github.com/PX4/Firmware/blob/master/cmake/configs/nuttx_px4fmu-v2_default.cmake)，编译运行。
3. 连接到控制台。输入px4_simple_app

	```sh
	nsh > px4_simple_app
	Hello Sky!
	```
为了做一些有意义的事情，应用程序需要订阅输入和发布输出。两个应用程序之间独立的消息通道叫做*topics*。
4. 订阅传感器数据。伪代码如下：

	```c
	#include <poll.h>
	#include <uORB/topics/sensor_combined.h>
	..
	int sensor_sub_fd = orb_subscribe(ORB_ID(sensor_combined));

	/* one could wait for multiple topics with this technique, just using one here */
	px4_pollfd_struct_t fds[] = {
	    { .fd = sensor_sub_fd,   .events = POLLIN },
	};

	while (true) {
	    /* wait for sensor update of 1 file descriptor for 1000 ms (1 second) */
	    int poll_ret = px4_poll(fds, 1, 1000);
	..
	    if (fds[0].revents & POLLIN) {
	        /* obtained data for the first file descriptor */
	        struct sensor_combined_s raw;
	        /* copy sensors raw data into local buffer */
	        orb_copy(ORB_ID(sensor_combined), sensor_sub_fd, &raw);
	        printf("[px4_simple_app] Accelerometer:\t%8.4f\t%8.4f\t%8.4f\n",
	                    (double)raw.accelerometer_m_s2[0],
	                    (double)raw.accelerometer_m_s2[1],
	                    (double)raw.accelerometer_m_s2[2]);
	    }
	}
	```
编译后运行如下：

	```sh
	nsh > px4_simple_app &
	[px4_simple_app] Accelerometer:   0.0483          0.0821          0.0332
	[px4_simple_app] Accelerometer:   0.0486          0.0820          0.0336
	[px4_simple_app] Accelerometer:   0.0487          0.0819          0.0327
	[px4_simple_app] Accelerometer:   0.0482          0.0818          0.0323
	[px4_simple_app] Accelerometer:   0.0482          0.0827          0.0331
	[px4_simple_app] Accelerometer:   0.0489          0.0804          0.0328
	```
5. 发布数据。为了使用计算后的输出，下一步就是发布结果。    
初始化将要发布的话题的结构，宣传话题：

	```c
	#include <uORB/topics/vehicle_attitude.h>
	..
	/* advertise attitude topic */
	struct vehicle_attitude_s att;
	memset(&att, 0, sizeof(att));
	orb_advert_t att_pub_fd = orb_advertise(ORB_ID(vehicle_attitude), &att);
	```
主循环中需要的时候发布信息：

	```c
	orb_publish(ORB_ID(vehicle_attitude), att_pub_fd, &att);
	```
最后编译运行程序` px4_simple_app`。


>注意：由`px4_task_spawn()`来产生守护进程daemon。

了解了上面的基础后，下面将分应用进行分析。   
**综述**：    
 1. 三角函数直接解算欧拉角+互补滤波+单级PID版本    
效果：简单暴力，但是补滤波效果差，单级PID响应慢，打舵跟随效应差。    
2. 三角函数直接解算欧拉角+卡尔曼滤波+单级PID版本     
效果：卡尔曼滤波噪声偏大，滞后略微严重，单级PID难操作，打舵响应慢，跟随效应差。不过比较适合初学四轴的人，难度比四元数加串级PID版本低，易于理解。    
3. 四元数姿态解算+互补滤波（德国开源四轴）+串级PID版本    
效果：四元数难理解，基于PI控制的互补滤波不适合非专业人员，PID参数较单级PID参数难调。打舵响应极佳，稳定程度高，易于操作，是目前四轴的主流算法

<br>
####姿态估算
#####DCM理论
>`注意`：这部分属于APM里px4姿态结算部分。    
>`资料解读`:[DMCDraft2.pdf](http://pan.baidu.com/wap/shareview?&shareid=523287088&uk=1395271735&dir=%2F%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%E8%B5%84%E6%96%99&page=2&num=20&fsid=676179599906396&third=0)

- 使用矩阵来控制和导航，元素包括陀螺仪，加速度计和gps信息。
- 总的来说，DCM工作如下：
 - 陀螺仪作为主要的方向信息来源，通过整合一个非线性微分运动方程，表明飞机方向的变化率与旋转速率及它当前的方向之间的关系。
 - 意识到积分过程中的积分误差将渐渐的违反DCM必须满足的正交约束，我们对矩阵的元素进行规则的小调整满足约束。
 - 由于数字误差，陀螺仪漂移，陀螺仪偏移量将逐渐积累在DCM中的元素的误差，我们使用参考向量来检测误差，以及在检测到的误差和和第一步的陀螺仪输入中加一个比例积分负反馈控制器来在建立之前消除误差。gps是用来检测偏航误差，加速度计被用来检测俯仰和滚动。   
 `整个过程`如下：

 	<img src="/images/dcm.png">
- 所有这一切都与旋转有关。
- 有几种方法可以做到，比如旋转矩阵和四元数。这两种方法在实现上具有相似的地方，都是尽量准确的表示旋转。四元数只需要4个值，而旋转矩阵需要9个，在这方面四元数具有优势。而旋转矩阵很适合用来导航和控制。
- 旋转矩阵用来描述一个坐标系相对于另一个坐标系的方向。在一个系统中的向量可以通过乘以旋转矩阵转变到另一个系统中，如果是相反方向旋转则乘以旋转矩阵的逆矩阵，也是它的转置（交换行和列）。单位向量在控制和导航运算中将非常有用，因为它们的长度为1。因此他们能被用于交积和叉积中来获得各种正弦或余弦角。

	<img src="/images/R.png">
	<img src="/images/RR.png">
- 随着飞机的飞行，我们可以用位置（重心的移动）和朝向（绕着重心方向的变化）了描述它的运动，类似这种变换我们称为刚体变换。通过指定一个轴的旋转来描述其相对于地球的方向。例如将飞机开始放在一个标准方向，然后将其旋转，它将指向另外一个实际的方向，也就是说任何其他的方向都可以通过标准方向的旋转描述。    
旋转组是所有可能的旋转的组。它被称为一组，因为在该组中的任何2个旋转可以组成一个组中的另一个旋转，每一个旋转有一个逆旋转。这里有一个单位旋转。    
旋转组应该得到重视的原因是，你能通过最少的近似来在各个方向控制和导航飞机，包括各种特技。   
基本的想法是，定义了你的飞机的方向的旋转矩阵，可以通过结合描述旋转运动学的非线性微分方程得到。这个结合可以通过一系列的旋转组合完成，也就是两矩阵相乘，这是两个矩阵依次执行的结果。   
然而，数值积分引入的数值误差，并不会产生与符号积分相同的结果。精确的陀螺仪信号的符号积分将产生完全正确的旋转矩阵。数值积分，即使我们有精确的陀螺仪信号，也会引入2种数值误差：
 - 积分误差。数值积分采用有限时间步长和在有限采样速率下采样数据。因为是假定在时间步长内旋转速度是恒定的，这将引入了一个与旋转加速度成比例的误差。
 - 量化误差。不管你用什么代表值，数字表示是有限的，所以有一个量化误差，从模数转换开始，以及所有计算没有保留结果所有位时。
- [旋转矩阵](http://blog.csdn.net/zhang11wu4/article/details/49761121)的一个关键特性是它的正交性，这意味着如果2个向量在一个参照系中是垂直的，它们在每一个参照系中都是垂直的。另外，在每一个参照系中向量的长度是一样的。数值误差可能违反此特性。例如，即使行和列都应该代表单位向量，它们的大小应该等于1，但数值误差可能导致它们变得更小或更大。最终他们可以缩小到零，或去无限。行和列应该是垂直于彼此，数值误差可能导致他们“倾斜”到对方，如下图所示：

	<img src="/images/lean.png">
- 旋转矩阵有9个元素。实际上，只有3个是独立的。旋转矩阵的正交特性在数学术语方面意味着矩阵的任何一对行或列都是垂直的。并且在每个列（或行）的元素的平方和等于1。所以这九个元素中有六个约束条件。

	<img src="/images/cons.png">
- 反对称矩阵定义是：A=-A’（A的转置前加负号），它的第Ⅰ行和第Ⅰ列各数绝对值相等，符号相反。且主对角线上的元素为均为零。一个小的旋转可以用如下的反对称矩阵来描述：

	<img src="/images/anti.png">
- 在我们的例子中，运动学与刚体旋转的含义有关。它的结果是一个非线性微分方程，描述了刚体在其向量旋转速度方面的时间演化。方向余弦矩阵都是关于运动学的。
- 控制和导航可以在笛卡尔坐标系使用DCM完成叉积和点积运算。下面是具体步骤：
 - 要控制飞机的俯仰，你需要知道这架飞机的俯仰姿态，你可以通过把飞机的翻滚轴与地面垂直做点积。
 - 要控制飞机的翻滚，你需要知道这架飞机的倾斜姿态，你可以通过把飞机的俯仰轴与地面垂直做点积。
 - 要航向，你需要知道你这架飞机相对于你想要去的方向的偏航姿态，可以通过飞机的翻滚轴与想要去的方向的向量做叉积得到。如果是去相反的方向，则是点积运算。
 - 判断飞机是否倒过来，可以通过判断飞机偏航轴与垂直的点积符号，如果小于0，则是朝下的。
 - 计算飞机绕垂直轴的旋转速度，将陀螺仪的旋转矢量转换为地理参考坐标系，然后与垂直轴做点积。
- 下面将进行深入的理论研究。
- 确定一个合适的坐标系统描述飞机的运动是必要的。对于大多数处理飞机运动的问题，采用了双坐标系。一个坐标系是固定在地球上的，可以被认为是是一个惯性坐标系，是为了飞机运动分析的目的。另一个坐标系是固定在飞机上的，被称为机体坐标系。图2显示了两右手坐标系：

	<img src="/images/frame.png">

	其中 xe、ye、ze 是地球坐标系统,ze 指向地心,xe 指向正东方,ye 指向正北方;
xb、yb、zb 为机体坐标系。
- 飞机的方向经常被描述为三个连续的旋转，其顺序是重要的。旋转角被称为欧拉角。假设机体坐标如下：

	<img src="/images/body.png">

	进行如下的旋转就可以得到上面图2的结果：

	<img src="/images/rotate.png">

	分析：第一步:假设我站在机体坐标中,我需要通过先绕 Xb 轴旋转$$a^2 + b^2 = c^2$$，再旋转 Yb 轴
旋转，最后绕 Zb 轴旋转，回到地球坐标系;先求出每次旋转的矩阵。
- 方向余弦矩阵：向量的某些类型，如方向，速度，加速度，和转换，（动作）可以转化为旋转参考系中的一个3x3的矩阵。我们感兴趣的是机体参考系和地面参考系。它可以乘以一个向量的方向余弦矩阵旋转：

	<img src="/images/eqn1.png">
- 方向余弦矩阵与欧拉角之间的关系为：

	<img src="/images/eqn2.png">
- 方程1方程2表明了如何将机体坐标系中测得的向量转换的地理坐标系中。方程1是以方向余弦角的形式，而2为欧拉角。
- 地理坐标系中向量的每个分量等于相对应的旋转矩阵的行与机体坐标向量的点积。计算旋转矩阵需要9个乘法和6个加法运算。方程3是方程1的复述，用乘法展开向量和矩阵的元素。

	<img src="/images/eqn3.png">
- 注意：


<br>
####姿态控制


<br>
####参考文献
[陀螺仪加速度计MPU6050](http://www.crazepony.com/wiki/mpu6050.html)