---
layout: post
title:  "初学PX4之飞控算法"
categories: "drons_lifes"
author: 吴兴章
tags: 工作生活
donate: true
comments: true
---
学习应用程序就回到主线程上来了，这也是我研究px4的初衷，学习姿态估计与控制算法。    

<br>
####脚本分析
下面看下重要的一个[脚本](https://github.com/PX4/Firmware/blob/master/ROMFS/px4fmu_common/init.d/rc.mc_apps)`/etc/init.d/rc.mc_apps`，可以知道姿态估计用的是attitude_estimator_q和position_estimator_inav，用户也可以选择local_position_estimator、ekf2，而姿态控制应用为mc_att_control和mc_pos_control。

<!--more-->

```sh
#!nsh
#
# Standard apps for multirotors:
# att & pos estimator, att & pos control.
#

# The system is defaulting to INAV_ENABLED = 1
# but users can alternatively try the EKF-based
# filter by setting INAV_ENABLED = 0
if param compare INAV_ENABLED 1
then
	attitude_estimator_q start
	position_estimator_inav start
else
	if param compare LPE_ENABLED 1
	then
		attitude_estimator_q start
		local_position_estimator start
	else
		ekf2 start
	fi
fi

if mc_att_control start
then
else
	# try the multiplatform version
	mc_att_control_m start
fi

if mc_pos_control start
then
else
	# try the multiplatform version
	mc_pos_control_m start
fi

#
# Start Land Detector
#
land_detector start multicopter

```
<br>
####学写应用程序
在这之前，我们需要对在NuttX操作系统里怎么写应用程序做一个了解，这样好为下面的算法部分应用分析打好基础。    

下面我将参考下面这个[官方教程](http://dev.px4.io/tutorial-hello-sky.html)做一个大体的概括。    

1. 首先编写简单的应用[示例程序](https://github.com/PX4/Firmware/tree/master/src/examples/px4_simple_app)。主要有三个部分：头文件、外部声明、主函数。
2. 注册应用程序到NSH并编译。添加新的一行`examples/px4_simple_app`到[Firmware/cmake/configs/nuttx_px4fmu-v2_default.cmake](https://github.com/PX4/Firmware/blob/master/cmake/configs/nuttx_px4fmu-v2_default.cmake)，编译运行。
3. 连接到控制台。输入px4_simple_app

	```sh
	nsh > px4_simple_app
	Hello Sky!
	```
为了做一些有意义的事情，应用程序需要订阅输入和发布输出。两个应用程序之间独立的消息通道叫做*topics*。
4. 订阅传感器数据。伪代码如下：

	```c
	#include <poll.h>
	#include <uORB/topics/sensor_combined.h>
	..
	int sensor_sub_fd = orb_subscribe(ORB_ID(sensor_combined));

	/* one could wait for multiple topics with this technique, just using one here */
	px4_pollfd_struct_t fds[] = {
	    { .fd = sensor_sub_fd,   .events = POLLIN },
	};

	while (true) {
	    /* wait for sensor update of 1 file descriptor for 1000 ms (1 second) */
	    int poll_ret = px4_poll(fds, 1, 1000);
	..
	    if (fds[0].revents & POLLIN) {
	        /* obtained data for the first file descriptor */
	        struct sensor_combined_s raw;
	        /* copy sensors raw data into local buffer */
	        orb_copy(ORB_ID(sensor_combined), sensor_sub_fd, &raw);
	        printf("[px4_simple_app] Accelerometer:\t%8.4f\t%8.4f\t%8.4f\n",
	                    (double)raw.accelerometer_m_s2[0],
	                    (double)raw.accelerometer_m_s2[1],
	                    (double)raw.accelerometer_m_s2[2]);
	    }
	}
	```
编译后运行如下：

	```sh
	nsh > px4_simple_app &
	[px4_simple_app] Accelerometer:   0.0483          0.0821          0.0332
	[px4_simple_app] Accelerometer:   0.0486          0.0820          0.0336
	[px4_simple_app] Accelerometer:   0.0487          0.0819          0.0327
	[px4_simple_app] Accelerometer:   0.0482          0.0818          0.0323
	[px4_simple_app] Accelerometer:   0.0482          0.0827          0.0331
	[px4_simple_app] Accelerometer:   0.0489          0.0804          0.0328
	```
5. 发布数据。为了使用计算后的输出，下一步就是发布结果。    
初始化将要发布的话题的结构，宣传话题：

	```c
	#include <uORB/topics/vehicle_attitude.h>
	..
	/* advertise attitude topic */
	struct vehicle_attitude_s att;
	memset(&att, 0, sizeof(att));
	orb_advert_t att_pub_fd = orb_advertise(ORB_ID(vehicle_attitude), &att);
	```
主循环中需要的时候发布信息：

	```c
	orb_publish(ORB_ID(vehicle_attitude), att_pub_fd, &att);
	```
最后编译运行程序` px4_simple_app`。


>注意：由`px4_task_spawn()`来产生守护进程daemon。

了解了上面的基础后，下面将分应用进行分析。   
**综述**：    
 1. 三角函数直接解算欧拉角+互补滤波+单级PID版本    
效果：简单暴力，但是补滤波效果差，单级PID响应慢，打舵跟随效应差。    
2. 三角函数直接解算欧拉角+卡尔曼滤波+单级PID版本     
效果：卡尔曼滤波噪声偏大，滞后略微严重，单级PID难操作，打舵响应慢，跟随效应差。不过比较适合初学四轴的人，难度比四元数加串级PID版本低，易于理解。    
3. 四元数姿态解算+互补滤波（德国开源四轴）+串级PID版本    
效果：四元数难理解，基于PI控制的互补滤波不适合非专业人员，PID参数较单级PID参数难调。打舵响应极佳，稳定程度高，易于操作，是目前四轴的主流算法

<br>
####姿态估算
#####DCM理论
>`注意`：这部分属于APM里px4姿态结算部分。    
>`资料解读`:[DMCDraft2.pdf](http://pan.baidu.com/wap/shareview?&shareid=523287088&uk=1395271735&dir=%2F%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%E8%B5%84%E6%96%99&page=2&num=20&fsid=676179599906396&third=0)

- 使用矩阵来控制和导航，元素包括陀螺仪，加速度计和gps信息。
- 总的来说，DCM工作如下：
 - 陀螺仪作为主要的方向信息来源，通过整合一个非线性微分运动方程，表明飞机方向的变化率与旋转速率及它当前的方向之间的关系。
 - 意识到积分过程中的积分误差将渐渐的违反DCM必须满足的正交约束，我们对矩阵的元素进行规则的小调整满足约束。
 - 由于数字误差，陀螺仪漂移，陀螺仪偏移量将逐渐积累在DCM中的元素的误差，我们使用参考向量来检测误差，以及在检测到的误差和和第一步的陀螺仪输入中加一个比例积分负反馈控制器来在建立之前消除误差。gps是用来检测偏航误差，加速度计被用来检测俯仰和滚动。   
 `整个过程`如下：

 	<img src="/images/dcm.png">

 	代码实现概览：

	 ```c
	 // Integrate the DCM matrix using gyro inputs
	 matrix_update(delta_t);

	 // Normalize the DCM matrix
	 normalize();

	 // Perform drift correction
	 drift_correction(delta_t);
	 ```
- 所有这一切都与旋转有关。
- 有几种方法可以做到，比如旋转矩阵和四元数。这两种方法在实现上具有相似的地方，都是尽量准确的表示旋转。四元数只需要4个值，而旋转矩阵需要9个，在这方面四元数具有优势。而旋转矩阵很适合用来导航和控制。
- 旋转矩阵用来描述一个坐标系相对于另一个坐标系的方向。在一个系统中的向量可以通过乘以旋转矩阵转变到另一个系统中，如果是相反方向旋转则乘以旋转矩阵的逆矩阵，也是它的转置（交换行和列）。单位向量在控制和导航运算中将非常有用，因为它们的长度为1。因此他们能被用于交积和叉积中来获得各种正弦或余弦角。

	<img src="/images/R.png">
	<img src="/images/RR.png">
- 随着飞机的飞行，我们可以用位置（重心的移动）和朝向（绕着重心方向的变化）了描述它的运动，类似这种变换我们称为刚体变换。通过指定一个轴的旋转来描述其相对于地球的方向。例如将飞机开始放在一个标准方向，然后将其旋转，它将指向另外一个实际的方向，也就是说任何其他的方向都可以通过标准方向的旋转描述。    
旋转组是所有可能的旋转的组。它被称为一组，因为在该组中的任何2个旋转可以组成一个组中的另一个旋转，每一个旋转有一个逆旋转。这里有一个单位旋转。    
旋转组应该得到重视的原因是，你能通过最少的近似来在各个方向控制和导航飞机，包括各种特技。   
基本的想法是，定义了你的飞机的方向的旋转矩阵，可以通过结合描述旋转运动学的非线性微分方程得到。这个结合可以通过一系列的旋转组合完成，也就是两矩阵相乘，这是两个矩阵依次执行的结果。   
然而，数值积分引入的数值误差，并不会产生与符号积分相同的结果。精确的陀螺仪信号的符号积分将产生完全正确的旋转矩阵。数值积分，即使我们有精确的陀螺仪信号，也会引入2种数值误差：
 - 积分误差。数值积分采用有限时间步长和在有限采样速率下采样数据。因为是假定在时间步长内旋转速度是恒定的，这将引入了一个与旋转加速度成比例的误差。
 - 量化误差。不管你用什么代表值，数字表示是有限的，所以有一个量化误差，从模数转换开始，以及所有计算没有保留结果所有位时。
- [旋转矩阵](http://blog.csdn.net/zhang11wu4/article/details/49761121)的一个关键特性是它的正交性，这意味着如果2个向量在一个参照系中是垂直的，它们在每一个参照系中都是垂直的。另外，在每一个参照系中向量的长度是一样的。数值误差可能违反此特性。在许多空间系统中,利用方向余弦矩阵把矢量从一个笛卡尔坐标系变换到另一个笛卡尔坐标系。理想的方向余弦矩阵应当是正交的,而实际上,通过计算得到的矩阵由于种种误差(如计算方法误差、舍入误差等)而失去了正交性,造成变换误差,影响系统精度。于是有必要按某种最优方式,恢复其正交性。矩阵正交化的迭代法有多种,但都计算较繁、运算量大。对于需要把计算得到的方向余弦矩阵周期性地正交化的场合(如捷联式惯导系统),大的运算量将给计算机实时计算带来困难。例如，即使行和列都应该代表单位向量，它们的大小应该等于1，但数值误差可能导致它们变得更小或更大。最终他们可以缩小到零，或去无限。行和列应该是垂直于彼此，数值误差可能导致他们“倾斜”到对方，如下图所示：

	<img src="/images/lean.png">
- 旋转矩阵有9个元素。实际上，只有3个是独立的。旋转矩阵的正交特性在数学术语方面意味着矩阵的任何一对行或列都是垂直的。并且在每个列（或行）的元素的平方和等于1。所以这九个元素中有六个约束条件。

	<img src="/images/cons.png">
- 反对称矩阵定义是：A=-A’（A的转置前加负号），它的第Ⅰ行和第Ⅰ列各数绝对值相等，符号相反。且主对角线上的元素为均为零。一个小的旋转可以用如下的反对称矩阵来描述：

	<img src="/images/anti.png">
- 在我们的例子中，运动学与刚体旋转的含义有关。它的结果是一个非线性微分方程，描述了刚体在其向量旋转速度方面的时间演化。方向余弦矩阵都是关于运动学的。
- 控制和导航可以在笛卡尔坐标系使用DCM完成叉积和点积运算。下面是具体步骤：
 - 要控制飞机的俯仰，你需要知道这架飞机的俯仰姿态，你可以通过把飞机的翻滚轴与地面垂直做点积。
 - 要控制飞机的翻滚，你需要知道这架飞机的倾斜姿态，你可以通过把飞机的俯仰轴与地面垂直做点积。
 - 要航向，你需要知道你这架飞机相对于你想要去的方向的偏航姿态，可以通过飞机的翻滚轴与想要去的方向的向量做叉积得到。如果是去相反的方向，则是点积运算。
 - 判断飞机是否倒过来，可以通过判断飞机偏航轴与垂直的点积符号，如果小于0，则是朝下的。
 - 计算飞机绕垂直轴的旋转速度，将陀螺仪的旋转矢量转换为地理参考坐标系，然后与垂直轴做点积。
- 下面将进行深入的理论研究。
- 确定一个合适的坐标系统描述飞机的运动是必要的。对于大多数处理飞机运动的问题，采用了双坐标系。一个坐标系是固定在地球上的，可以被认为是是一个惯性坐标系，是为了飞机运动分析的目的。另一个坐标系是固定在飞机上的，被称为机体坐标系。图2显示了两右手坐标系：

	<img src="/images/frame.png">

	其中 xe、ye、ze 是地球坐标系统,ze 指向地心,xe 指向正东方,ye 指向正北方;
xb、yb、zb 为机体坐标系。
- 飞机的方向经常被描述为三个连续的旋转，其顺序是重要的。旋转角被称为欧拉角。假设机体坐标如下：

	<img src="/images/body.png">

	进行如下的旋转就可以得到上面图2的结果：

	<img src="/images/rotate.png">

	`分析`：第一步:假设我站在机体坐标中,我需要通过先绕 Xb 轴旋转 \\(\Phi\\) ，再旋转 Yb 轴旋转 \\(\theta\\)，最后绕 Zb 轴旋转 \\(\psi\\)，回到地球坐标系;先求出每次旋转的矩阵。    
	如果绕机体 X 轴旋转的角度为 \\(\Phi\\)，那么

	<img src="/images/L1.png">

	这里是怎么得来的呢？先说一下什么是旋转矩阵？如下图所示，我们假设最开始空间的坐标系也就是机体坐标系XA，YA，ZA就是笛卡尔坐标系，这样我们得到空间A的矩阵VA={XA，YA，ZA}T，其实也可以看做是`单位阵E`。进过旋转后，空间A的三个坐标系变成了图1中红色的三个坐标系XB，YB，ZB，得到空间B的矩阵VB={XB，YB，ZB}T。我们将两个空间联系起来可以得到VB=R•VA，这里R就是我们所说的旋转矩阵。

	<img src="http://images0.cnblogs.com/blog2015/791740/201508/060205044088686.png">

	由于XA={1,0,0}T，YA={0,1,0}T，ZA={0,0,1}T，结合图2可以看出，旋转矩阵R就是由XB，YB，ZB 三个向量组成的。讲到这里，大家应该会发现旋转矩阵R满足第一个条件，因为单位向量无论怎么旋转长度肯定不会变而且向量之间的正交性质也不会变。那么旋转矩阵就是正交阵！不过这还不能说明问题，下面我更进一步利用数学公式进行证明。

	<img src="http://images0.cnblogs.com/blog2015/791740/201508/060154505647587.png">

	进一步讨论之前，我们先说两点数学知识。（1）点乘（dot product）的几何意义：如图3，我们从点乘的公式可以得到α•β相当与β的模乘上α在β上投影的模，所以当|β|=1时，α•β就是指α在β上投影的模。这一点在下面的内容中非常重要，之所以叫余弦矩阵的原因就是这个。（2）旋转矩阵逆的几何意思：这个比较抽象，不过也好理解。旋转矩阵相当于把一个向量（空间）旋转成新的向量（空间），那么逆可以理解为由新的向量（空间）转回原来的向量（空间）。（3）向量是特殊的矩阵，只有一行或一列的矩阵称为向量。向量有叉乘和点乘。矩阵也有，但意义不一样，矩阵还有反对称，逆矩阵等。

	<img src="http://images0.cnblogs.com/blog2015/791740/201508/060214481586681.png">

	所以上面的公式解析如下：

	<img src="http://images0.cnblogs.com/blog2015/791740/201508/060231194231745.png">

	<img src="http://images0.cnblogs.com/blog2015/791740/201508/061036414865256.png">

	同理，其他方向的旋转计算如下：   
	如果绕机体 Y 轴旋转的角度为 \\(\theta\\)，那么

	<img src="/images/L2.png">

	如果绕机体 Z 轴旋转的角度为 \\(\psi\\)，那么

	<img src="/images/L3.png">

	第二步:由于站在机体坐标上需要按照 X->Y->Z 轴的顺序,经过 3 次旋转,才能回到地球坐标系;反过来如果站在地球坐标系,则需要经过 Z->Y->X 的三次旋转才能到达机体坐标系;因为我们可以列出从地球坐标系到机体坐标系的 DCM矩阵。
	$$L(\Phi, \theta, \psi) = L(\psi) * L(\theta) * L(\Phi);$$
	矩阵的乘法计算得：

	<img src="/images/endl.png">

- 方向余弦矩阵：向量的某些类型，如方向，速度，加速度，和转换，（动作）可以转化为旋转参考系中的一个3x3的矩阵。我们感兴趣的是机体参考系和地面参考系。它可以乘以一个向量的方向余弦矩阵旋转：

	<img src="/images/eqn1.png">
- 由上面的分析可知，方向余弦矩阵与欧拉角之间的关系为：

	<img src="/images/eqn2.png">
- 方程1方程2表明了如何将机体坐标系中测得的向量转换的地理坐标系中。方程1是以方向余弦角的形式，而2为欧拉角。

	<img src="/images/LLL.png">

	以上整个求解过程是对 matrix3.cpp 代码中 from_euler 函数的解析：

	```c
	// create a rotation matrix given some euler angles
	// this is based on http://gentlenav.googlecode.com/files/EulerAngles.pdf
	template <typename T>
	void Matrix3<T>::from_euler(float roll, float pitch, float yaw)
	{
	    float cp = cosf(pitch);//pitch 表示俯仰相对于地球坐标系的角度值
	    float sp = sinf(pitch);
	    float sr = sinf(roll);//roll 表示横滚相对于地球坐标系的角度值
	    float cr = cosf(roll);
	    float sy = sinf(yaw);//yaw 表示偏航相对于地球坐标的角度值
	    float cy = cosf(yaw);

	    a.x = cp * cy;
	    a.y = (sr * sp * cy) - (cr * sy);
	    a.z = (cr * sp * cy) + (sr * sy);
	    b.x = cp * sy;
	    b.y = (sr * sp * sy) + (cr * cy);
	    b.z = (cr * sp * sy) - (sr * cy);
	    c.x = -sp;
	    c.y = sr * cp;
	    c.z = cr * cp;
	}
	```
	其中a，b，c为类定义的私有变量---向量。   
	通过不同的旋转顺序可以得到不同的旋转矩阵，如果从地球坐标系到体坐标系,按照 Z->X->Y 轴的顺序旋转可以得到from_euler312函数，这里就没做具体讲解。

	`问题`：反过来也就可以通过方向余弦矩阵来求出旋转角

	<img src="/images/3r.png">

	函数 to_euler 式通过上面的 3 个公式求出对应的角度的

	```c
	// calculate euler angles from a rotation matrix
	// this is based on http://gentlenav.googlecode.com/files/EulerAngles.pdf
	template <typename T>
	void Matrix3<T>::to_euler(float *roll, float *pitch, float *yaw) const
	{
	    if (pitch != NULL) {
	        *pitch = -safe_asin(c.x);
	    }
	    if (roll != NULL) {
	        *roll = atan2f(c.y, c.z);
	    }
	    if (yaw != NULL) {
	        *yaw = atan2f(b.x, a.x);
	    }
	}
	```

- 地理坐标系中向量的每个分量等于相对应的旋转矩阵的行与机体坐标向量的点积。计算旋转矩阵需要9个乘法和6个加法运算。方程3是方程1的复述，用乘法展开向量和矩阵的元素。所以如果知道机体坐标向量，即可得地理坐标向量的大小：

	<img src="/images/eqn3.png">
- 需要注意的是，矩阵R不一定是对称的。R矩阵的三列对应于机体坐标的三个轴向量到地理坐标的变换。R矩阵的三行则对应于地理坐标三个轴向量到机体坐标的变换。该R矩阵描述了所有机体相对于地球方向的信息。R矩阵也称为方向余弦矩阵，因为每个分量都是机体坐标轴与地理坐标轴夹角的余弦，通过看推理余弦矩阵部分可以看出来。
- 矩阵的转置，特别在旋转矩阵中，表示为\\(R^T\\)，通过交换行和列得到。一般来说，一个方形矩阵的逆矩阵如果存在的话，表示为\\(R^{−1}\\)。矩阵的逆乘以矩阵得到的是单位矩阵。（单位矩阵就是对角线上元素为1,其余为0,单位矩阵乘以任何矩阵得到它本身），对于旋转矩阵来说，逆就等于它的转置。

	<img src="/images/eqn4.png">
- 之所以旋转矩阵逆就等于它的转置考虑到了对称性的情况。旋转矩阵的元素都是机体轴与地理坐标轴之间的余弦值，相反的情况就相当于交换地理坐标和机体坐标的角色，也就是说交换行与列，这跟转置是一样的。实际上这又和正交条件达成一致：
 - 正交矩阵每一列都是单位矩阵，并且两两正交。最简单的正交矩阵就是单位阵。
 - 正交矩阵的逆（inverse）等于正交矩阵的转置（transpose）。同时可以推论出正交矩阵的行列式的值肯定为正负1的。
 - 正交矩阵满足很多矩阵性质，比如可以相似于对角矩阵等等。

	如下：

	<img src="/images/eqn5.png">

	这个方程用来证明矩阵的逆的矩阵的转置。
- 旋转矩阵的一个非常有用的特性是，我们可以组成旋转。

	<img src="/images/eqn6.png">

	这里特别需要小心运算顺序，因为它的效果是完全不一样的。
- 另外这里还有一些有用的特性，如：

	<img src="/images/eqn7.png">

- 下面介绍一下点乘和叉乘。
- 这里有两个DCM计算里边用到的向量运算——点乘和叉乘。点乘是表量运算，A向量作为行向量，B向量作为列向量。

	<img src="/images/eqn8.png">

	可以证明向量的点乘等于两个向量的长度乘以它们角度的余弦值。

	<img src="/images/eqn9.png">

	所以向量的点乘是对称的。A \\(\cdot\\) B = B \\(\cdot\\) A

	而两个向量的叉乘是一个向量。它的元素是这样计算的：

	<img src="/images/eqn10.png">

	从物理意义上来分析：

	<img src="/images/eqn11.png">

	所以叉乘是反对称的，A \\(\times\\) B = - B \\(\times\\) A
- 下面到了DCM算法的核心部分——由陀螺仪计算方向余弦矩阵。
- 核心概念：非线性微分方程——方向余弦的变化速率与陀螺仪之间的关系。我们的目标是计算方向余弦而不是任何违反方程非线性的近似解。目前，我们假设陀螺仪信号没有错误。稍后我们将解决陀螺仪漂移问题。   
不像机械陀螺，我们不能通过简单地积分陀螺仪信号得到角度。一个有名的运动学公式，关于旋转向量的变化率和它的旋转之间的关系：

	<img src="/images/eqn12.png">

	有一个需要注意的地方：

	 - 微分方程是非线性的。旋转向量输入是与我们要进行积分的变量进行叉乘。因此，任何线性的方法都只是一种近似。
	 - 两个向量都应该在同一个坐标系中测量。
	 - 因为叉乘是不对称的，所以我们需要保存结果，然后改变它的方向。
- 如果知道了初始状态和旋转向量的时间，我们可以通过方程11的数值积分来跟踪旋转向量。

	<img src="/images/eqn13.png">

	将方程13用于R矩阵的行或列中，可看作成旋转向量。   
	这里遇到的第一个问题是，我们要跟踪的向量和旋转向量不是在同一坐标系做测量的。理想情况下，我们都是在地理坐标轴中跟踪机体坐标轴，但是陀螺仪是在机体坐标中测量的。一个简单的方法是通过对称性解决，地理坐标在机体坐标中旋转和机体坐标在地理坐标中旋转是相反的，所以只要改变陀螺仪的符号就好了，更加方便的方法是，交换叉乘的顺序就好了。

	<img src="/images/eqn14.png">

	这里的向量代表的是方程1中R矩阵的行。下面的问题是怎么实施方程14，回归到方程14的微分方程形式：

	<img src="/images/eqn15.png">

	由这里可知方向余弦矩阵R的行都是通过\\(r_{earth}(t) \times d\theta(t)\\)积分得到的。   
	所以`根据陀螺仪的角度值,来计算当前机体的姿态 DCM矩阵`，其使用的方法是：机体坐标的每个轴的向量与 g(陀螺仪改变的角度向量)求叉积，这里求的是角度改变后,姿态在各个方向上的变化量，所以最后使用了矩阵的加法。源码matrix3.cpp中的函数体现如下：

	```c++
	// apply an additional rotation from a body frame gyro vector
	// to a rotation matrix.
	template <typename T>
	void Matrix3<T>::rotate(const Vector3<T> &g)
	{
	    Matrix3<T> temp_matrix;
	    temp_matrix.a.x = a.y * g.z - a.z * g.y;
	    temp_matrix.a.y = a.z * g.x - a.x * g.z;
	    temp_matrix.a.z = a.x * g.y - a.y * g.x;
	    temp_matrix.b.x = b.y * g.z - b.z * g.y;
	    temp_matrix.b.y = b.z * g.x - b.x * g.z;
	    temp_matrix.b.z = b.x * g.y - b.y * g.x;
	    temp_matrix.c.x = c.y * g.z - c.z * g.y;
	    temp_matrix.c.y = c.z * g.x - c.x * g.z;
	    temp_matrix.c.z = c.x * g.y - c.y * g.x;

	    (*this) += temp_matrix;
	}
	```
- 还有一件事需要做，陀螺仪漂移将在后面进行。我们需要通过比例积分补偿反馈控制器来添加旋转速率校准到陀螺仪测量的数据上，以此产生最优的角速率估计。

	<img src="/images/eqn16.png">

	基本上，我们的GPS和加速度计的参考向量被用来计算旋转误差，并通过反馈控制器输入计算，然后更新原有计算。

#####DCM_tutorial
>http://www.starlino.com/imu_guide.html/http://www.itdadao.com/2016/03/19/629990/   
>http://www.starlino.com/dcm_tutorial.html/https://github.com/nephen/picquadcontroller/blob/master/imu.h

<br>
####姿态控制


<br>
####参考文献
[陀螺仪加速度计MPU6050](http://www.crazepony.com/wiki/mpu6050.html)