---
layout: post
title:  "学习C++有感"
categories: "work_lifes"
author: 吴兴章
tags: 工作生活
donate: true
comments: true
---
####阅读笔记
- C语言是面向过程的语言，支持模块化、结构化的方法。C++融合了OOP、通用编程和传统的过程性方法，这表明C++强调的是实用价值，而不是意识形态方法，这也是该语言获得成功的原因之一。
- 才发现CC为标准UNIX C++编译器，而cc为标准UNIX C编译器。g++为GNU C++编译器，而GNU C++编译器的MS-DOS版本名为gpp。comeau编译器最为严格、标准。都是先生成.o文件，在生成.out文件。
- 在C中，main函数括号为空表示对是否接受参数保持沉默，而在C++中为空与跟void一样。C++中main函数默认返回0。
- C++预处理器对添加的头文件去掉了.h格式，当然也兼容以前的C格式。
- 如果省略using编译指令，必须这样编码std::cout，如果单独使用这个函数，可以这样：using std::cout，using指令可以根据应用的范围放在合适的位置。
- 标记与空白的概念。
- C++允许使用连续赋值。
- cout是可扩展的，允许自行开发新的数据类型。

<!--more-->
- C++允许在函数的任何地方声明新变量。
- 在C中，有返回值的函数称为函数，没有返回值的函数称为过程。C++中，这两种变体都是函数。
- 类是用户定义的数据类型规范。面向对象编程(OPP)的本质是设计并扩展自己的数据类型。内置的C++内型分为基本类型和复合类型。
- 在C++中，以两个下划线或下划线和大写字母大头的名称被保留给实现使用，以一个下划线开头的名称被保留实现，用作全局标识符，但他们都是有效的。
- short至少16位；int至少和short一样长；long至少32位，且至少与int一样长。
- sizeof对类型名使用时，必须加上括号。
- C++使用前一(两)位来标识数字常量的基数。如果第一位是1～9，则基数为10；如果第一位为0，第二位为1～7，则基数为8；如果前两位为0x或0X，则基数为16。
- 数据后缀标识存储的类型，如2344L，默认情况下为int型，除非太大，int装不下。
- 转义序列和通用字符(以\u和\U打头)。
- char在默认情况下既不是有符号，也不是没符号。在符号很重要的情况下，一定要特别声明。
- 存在一种wchar_t的宽字符类型。
- C++中存在bool类型，任何非零值都被转换为true，任何零被转换为false。
- 关键字const叫做限定符。
- E表示法适合于非常大和非常小的浮点数。如：+3.45E+6指的是3.45与1000000相乘的结果，E后为负数代表除以10的乘方。
- cout.setf(ios_base::fixed, ios_base::floatfield);，这样可以显示浮点数多余的零。
- 操作符重载：int除法、float除法和double除法。
- 赋值计算在类型转换时，较大的数转换为较小的数时，原来的值可能超过目标类型的取值范围，这种情况结果将是不可确定的。将浮点型转换为整形时，C++采取截取(丢弃小数部分)，而不是四舍五入。
- true被转换为1，false被转换为0，这些转换称为整形提升(int 类型计算速度更快)。
- 传统C语言总是将float提升为double，即使两个操作数都是float。
- 强制类型转换的格式为：(typeName)value/typeName(value)，第一种来自C语言，第二种来自C++语言。
- 用引号括起的字符串隐式的包括了结尾的空字符。如“S”表示两个字符，而‘S’单表示一个字符，更糟糕的是，“S”表示的是一个内存的地址。
- strlen函数返回的是存储在数组中字符串的长度，而不是数组本身的长度。另外strlen不会计算空字符。
- 为了能够输入多个单词，可以使用cin.getline()函数和cin.get()函数，getline丢弃了换行符，存储时用空字符替换，而get保留在了输入序列中，所以在使用这种方法时，需要不带任何参数的cin.get()调用读取下一个字符，也可以连续调用，如cin.get(name,ArSize).get()。
- string在C++中是作为类出现。string类具有自动调整大小的功能。输入字符串的方法为getline(cin,str)。
- C++允许在结构声明中省略关键字struct，结构体成员中也能进行赋值操作。
- 结构中的位字段：字段的类型应该为整形或枚举型，接下来是冒号，冒号后面是一个数字，它指定了使用的位数。通常用在低级编程中。
- 匿名共用体：将共用体用于结构体中，它们的地址相同，所以不需要中间标识符。
- 枚举、枚举量：默认情况，第一个枚举量为0。另外枚举变量只定义了赋值运算，没有定义算术运算。可自动转换为int型。如果只打算使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称。可以创建多个值相同的枚举量。可以将在取值范围内的任意整数赋给枚举量。
- 面向对象编程和传统的过程性编程的区别在于，OOP强调的是在运行阶段(而不是编译阶段)进行决策。动态联编/静态联编。
- 指针声明必须指定指针指向的数据类型。创建指针时，只会分配存储地址的内存，如int一般是一个4个字节的值,64位系统为8。创建指针时返回值为0表示空置指针。
- 如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。
- <img src="/images/cpoiter.png">

	`警告`：delete对空指针使用是安全的。不能释放同一个内存块两次。
- 对于数组的创建与删除：int* psome = new int[10]/delete [] psome。指针加减一表示向前后移动一个元素。C++将数组名解释为数组第一个元素的地址。
- 数组与指针的一些区别：数组名是常量，而指针值是可以修改的。sizeof取数组为数组的长度，这种情况不会把数组名解释为地址。
- 指针运算：两个指针的差将得到一个整数。
- “flower”传递的是字符串第一个字符的地址。
- 如果给cout提供一个地址，如果指针的类型为char *，则cout将显示字符串，如果要显示字符串的地址，应该使用int *。
- 如果结构标识符是结构名，则使用句点操作符；如果标识符是指向结构的指针，则使用箭头操作符。

	`注意`：ps->volume与(*ps).volume等价。
- 管理数据内存的方式：自动存储、静态存储、动态存储。
- 内存泄漏：如果没有调用delete，包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在，但由于无法继续访问，因为指向这些内存的指针无效，这将导致内存泄漏。
- C++常在for和括号之间加上一个空格，而省略函数名与括号之间的空格。

	<img src="/images/forc.png">

	在设计循环时，请记住下面几条知道原则：   
	- 确定循环终止的条件
	- 在首次测试之前初始化条件
	- 在条件再次测试之前更新条件

- cout.setf(ios::boolalpha)函数调用设置了一个标记，该标记命令cout显示true和false，而不是1和0。
- 顺序点是程序执行过程中的一个点，进入下一步之前确保对所有的副作用都进行评估。赋值操作符、递增操作符和递减操作符执行的所有修改是在顺序点完成。应避免这样的语句：y = (4 + x++) + (6 + x++);
- 后缀递增版本首先需要复制一个版本，再将其加1，然后将复制的拷贝返回，因此前缀版本的效率比后缀版本高。
- C++规定，逗号表达式的值是第二部分的值。如cats = (17,24)为24。
- C-风格字符串是通过结尾的空值字符定义的，而不是由其所在数组的长度定义的。这意味着两个字符串即使被存储在长度不同的数组中，也可能是相同的。
- for循环里可以重新定义变量，这个变量可能只能在这个循环体里有效，但是循环体里定义的变量只能在循环体里使用。
- C-风格字符串大小比较需要使用strcmp()函数，而C++风格可直接进行比较。
- cin将忽略空格和换行，如需读取，请使用cin.get(ch)，其返回的是cin对象，在需要bool值的地方可以自动转换。相当于C规则的getchar(ch)
- ctrl + D/Z相当于EOF，可以使用cin.eof()/cin.fail()返回的boo值进行检测。
	<img src="/images/getch.png">
- 从存储空间的角度来讲，指针数组比char数组的数组更为经济。
- C++规定，||等逻辑操作符是一个顺序点。另外，冒号和逗号操作符也是顺序点。
- if(17 < age < 35)的含义为if((17 < age) < 35)，所以一直为真。
- &&的优先级高于||。