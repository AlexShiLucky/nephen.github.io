---
layout: post
title:  "学习C++有感"
categories: "work_lifes"
author: 吴兴章
tags: 工作生活
donate: true
comments: true
---
####阅读笔记
- C语言是面向过程的语言，支持模块化、结构化的方法。C++融合了OOP、通用编程和传统的过程性方法，这表明C++强调的是实用价值，而不是意识形态方法，这也是该语言获得成功的原因之一。
- 才发现CC为标准UNIX C++编译器，而cc为标准UNIX C编译器。g++为GNU C++编译器，而GNU C++编译器的MS-DOS版本名为gpp。comeau编译器最为严格、标准。都是先生成.o文件，在生成.out文件。
- 在C中，main函数括号为空表示对是否接受参数保持沉默，而在C++中为空与跟void一样。C++中main函数默认返回0。
- C++预处理器对添加的头文件去掉了.h格式，当然也兼容以前的C格式。
- 如果省略using编译指令，必须这样编码std::cout，如果单独使用这个函数，可以这样：using std::cout，using指令可以根据应用的范围放在合适的位置。
- 标记与空白的概念。
- C++允许使用连续赋值。
- cout是可扩展的，允许自行开发新的数据类型。

<!--more-->
- C++允许在函数的任何地方声明新变量。
- 在C中，有返回值的函数称为函数，没有返回值的函数称为过程。C++中，这两种变体都是函数。
- 类是用户定义的数据类型规范。面向对象编程(OPP)的本质是设计并扩展自己的数据类型。内置的C++内型分为基本类型和复合类型。
- 在C++中，以两个下划线或下划线和大写字母大头的名称被保留给实现使用，以一个下划线开头的名称被保留实现，用作全局标识符，但他们都是有效的。
- short至少16位；int至少和short一样长；long至少32位，且至少与int一样长。
- sizeof对类型名使用时，必须加上括号。
- C++使用前一(两)位来标识数字常量的基数。如果第一位是1～9，则基数为10；如果第一位为0，第二位为1～7，则基数为8；如果前两位为0x或0X，则基数为16。
- 数据后缀标识存储的类型，如2344L，默认情况下为int型，除非太大，int装不下。
- 转义序列和通用字符(以\u和\U打头)。
- char在默认情况下既不是有符号，也不是没符号。在符号很重要的情况下，一定要特别声明。
- 存在一种wchar_t的宽字符类型。
- C++中存在bool类型，任何非零值都被转换为true，任何零被转换为false。
- 关键字const叫做限定符。
- E表示法适合于非常大和非常小的浮点数。如：+3.45E+6指的是3.45与1000000相乘的结果，E后为负数代表除以10的乘方。
- cout.setf(ios_base::fixed, ios_base::floatfield);，这样可以显示浮点数多余的零。
- 操作符重载：int除法、float除法和double除法。
- 赋值计算在类型转换时，较大的数转换为较小的数时，原来的值可能超过目标类型的取值范围，这种情况结果将是不可确定的。将浮点型转换为整形时，C++采取截取(丢弃小数部分)，而不是四舍五入。
- true被转换为1，false被转换为0，这些转换称为整形提升(int 类型计算速度更快)。
- 传统C语言总是将float提升为double，即使两个操作数都是float。
- 强制类型转换的格式为：(typeName)value/typeName(value)，第一种来自C语言，第二种来自C++语言。
- 用引号括起的字符串隐式的包括了结尾的空字符。如“S”表示两个字符，而‘S’单表示一个字符，更糟糕的是，“S”表示的是一个内存的地址。
- strlen函数返回的是存储在数组中字符串的长度，而不是数组本身的长度。另外strlen不会计算空字符。
- 为了能够输入多个单词，可以使用cin.getline()函数和cin.get()函数，getline丢弃了换行符，存储时用空字符替换，而get保留在了输入序列中，所以在使用这种方法时，需要不带任何参数的cin.get()调用读取下一个字符，也可以连续调用，如cin.get(name,ArSize).get()。
- string在C++中是作为类出现。string类具有自动调整大小的功能。输入字符串的方法为getline(cin,str)。

	```c
	for (int i = 0; i < SIZE; i++)
	{
		cout << i + 1 << ": ";
		getline(cin, list[i]);
	}
	```
- C++允许在结构声明中省略关键字struct，结构体成员中也能进行赋值操作。
- 结构中的位字段：字段的类型应该为整形或枚举型，接下来是冒号，冒号后面是一个数字，它指定了使用的位数。通常用在低级编程中。
- 匿名共用体：将共用体用于结构体中，它们的地址相同，所以不需要中间标识符。
- 枚举、枚举量：默认情况，第一个枚举量为0。另外枚举变量只定义了赋值运算，没有定义算术运算。可自动转换为int型。如果只打算使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称。可以创建多个值相同的枚举量。可以将在取值范围内的任意整数赋给枚举量。
- 面向对象编程和传统的过程性编程的区别在于，OOP强调的是在运行阶段(而不是编译阶段)进行决策。动态联编/静态联编。
- 指针声明必须指定指针指向的数据类型。创建指针时，只会分配存储地址的内存，如int一般是一个4个字节的值,64位系统为8。创建指针时返回值为0表示空置指针。
- 如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。
- <img src="/images/cpoiter.png">

	`警告`：delete对空指针使用是安全的。不能释放同一个内存块两次。
- 对于数组的创建与删除：int* psome = new int[10]/delete [] psome。指针加减一表示向前后移动一个元素。C++将数组名解释为数组第一个元素的地址。
- 数组与指针的一些区别：数组名是常量，而指针值是可以修改的。sizeof取数组为数组的长度，这种情况不会把数组名解释为地址。
- 指针运算：两个指针的差将得到一个整数。
- “flower”传递的是字符串第一个字符的地址。
- 如果给cout提供一个地址，如果指针的类型为char *，则cout将显示字符串，如果要显示字符串的地址，应该使用int *。
- 如果结构标识符是结构名，则使用句点操作符；如果标识符是指向结构的指针，则使用箭头操作符。

	`注意`：ps->volume与(*ps).volume等价。
- 管理数据内存的方式：自动存储、静态存储、动态存储。
- 内存泄漏：如果没有调用delete，包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在，但由于无法继续访问，因为指向这些内存的指针无效，这将导致内存泄漏。
- C++常在for和括号之间加上一个空格，而省略函数名与括号之间的空格。

	<img src="/images/forc.png">

	在设计循环时，请记住下面几条知道原则：   
	- 确定循环终止的条件
	- 在首次测试之前初始化条件
	- 在条件再次测试之前更新条件

- cout.setf(ios::boolalpha)函数调用设置了一个标记，该标记命令cout显示true和false，而不是1和0。
- 顺序点是程序执行过程中的一个点，进入下一步之前确保对所有的副作用都进行评估。赋值操作符、递增操作符和递减操作符执行的所有修改是在顺序点完成。应避免这样的语句：y = (4 + x++) + (6 + x++);
- 后缀递增版本首先需要复制一个版本，再将其加1，然后将复制的拷贝返回，因此前缀版本的效率比后缀版本高。
- C++规定，逗号表达式的值是第二部分的值。如cats = (17,24)为24。
- C-风格字符串是通过结尾的空值字符定义的，而不是由其所在数组的长度定义的。这意味着两个字符串即使被存储在长度不同的数组中，也可能是相同的。
- for循环里可以重新定义变量，这个变量可能只能在这个循环体里有效，但是循环体里定义的变量只能在循环体里使用。
- C-风格字符串大小比较需要使用strcmp()函数，而C++风格可直接进行比较。
- cin将忽略空格和换行，如需读取，请使用cin.get(ch)，其返回的是cin对象，在需要bool值的地方可以自动转换。相当于C规则的getchar(ch)
- ctrl + D/Z相当于EOF，可以使用cin.eof()/cin.fail()返回的boo值进行检测，输入错误和EOF都将导致cin返回false，可以用cin.clear()进行清除然后重新输入。
	<img src="/images/getch.png">
- 从存储空间的角度来讲，指针数组比char数组的数组更为经济。
- C++规定，||等逻辑操作符是一个顺序点。另外，冒号和逗号操作符也是顺序点。
- if(17 < age < 35)的含义为if((17 < age) < 35)，所以一直为真。
- &&的优先级高于||。
- <img src="/images/cctype.png">
- C++的switch语句中，default标签是可选的，如果被省略，又没有匹配的标签，则程序将跳到switch语句后面的语句执行。
- 文本文件：对于输入，将执行相反的转换。即整数将被转换为数字字符序列，浮点数转换为数字字符和其他字符组成的字符序列，字符数据不需要做任何转换。
- iostream 提供了一个预先定义好的名为cout的ostream对象，而我们必须声明自己的ofstream对象。如：

	```c
	ofstream outFile;
	outFile.open("fish.txt");

	ofstream fout;
	cin >> filename;
	fout.open(filename);

	double wt = 125.9;
	outFile << wt;
	```
	总之，使用文件输出的主要步骤如下：   
	1. 包含头文件fstream。
	2. 创建一个ofstream对象。
	3. 将该ofstream对象同一个文件关联起来。
	4. 就像使用cout那样使用ofstream对象。

- inFile.good()在输入没有发生错误的时候返回true。表达式inFile>>value的结果为inFile，而在需要一个bool值的情况下，inFile的结果为inFile.good()，即true或false。

	<img src="/images/filegood.png">
- 在C++原型中，不指定参数列表时应使用省略号:

	```c
	void say_bye(...);
	```
	通常，仅当与接受可变参数的C函数(如printf())交互时才需要这样做。
- 函数原型的检查称为静态类型检查。
- cin >> total >> choices，如果输入4 2，那么total为4，choice为2。
- 在C++中，当且仅当用于函数头或函数原型中，int *arr 和int arr[]的含义才相同。
- 循环输入数组，显示数组

	```c
	int fill_array(double ar[], int limit)
	{
		using namespace std;
		double temp;
		int i;
		for (i = 0; i < limit; i++)
		{
			cout << "Enter value #" << (i + 1) << ": ";
			cin >> temp;
			if (!cin)
			{
				cin.clear();
				while (cin.get() != '\n')
					continue;
				cout << "Bad input : input process terminated.\n";
				break;
			}
			else if (temp < 0)
				break;
			ar[i] = temp;
		}
		return i;
	}
	void show_array(const double ar[], int limit);
	```
- 关于const的两种情况：

	```c
	const float g_earth = 9.80;
	const float * pe = &g_earth;	//VALID

	const float g_moon = 1.63;
	float * pm = &g_moon;		//INVALID
	```
	只能将非const数据的地址赋给非const指针，如不能将const数组名作为参数传递给非常量形参的函数。所以加上const，能够处理const和非const实参。
- 二维数组函数定义：

	```c
	int sum(int ar2[][4], int size)
	{
		int total = 0;
		for (int r = 0; r < size; r++)
			for(int c = 0; c < 4; c++)
				total += ar2[r][c];
		return total;
	}
	```
- 当结构较小时，按值传递最合理。较大时使用按址传递。
- 递归案例：[ruler.cpp](https://github.com/nephen/cPrimerPlus/tree/master/chapter7/ruler.cpp)
- 函数指针基础知识
 - 函数名即为函数地址。
 - 函数指针声明。

 		<img src="/images/funstr.png">

 		例如 void estimate(int lines, double (*pf) (int));
 - 使用指针来调用函数，见[例子](https://github.com/nephen/cPrimerPlus/tree/master/chapter7/fun_ptr.cpp)。

		 ```c
		 double pam(int);
		 double (*pf) (int);
		 pf = pam;
		 double x = pam(4);
		 double y = (*pf)(4);
		 double z = pf(4);
		 ```
- 内联函数不能递归。与C语言的宏类似。只需在定义和声明前加上inline即可。
- 必须在声明引用时将其初始化。`注意`：在C++中，使用const，当形参的类型不对或不是左值时，将会自动创建临时变量，这样将不能修改作为参数传递的变量。

	<img src="/images/yy.png">

	引用可以用来交换数据。    
	void swapr(int &a, int &b);
- 结构引用：const sysop & use(sysop & sysopref);，请见[例程](https://github.com/nephen/cPrimerPlus/tree/master/chapter8/strtref.cpp)/[类对象](https://github.com/nephen/cPrimerPlus/tree/master/chapter8/strquote.cpp)，应避免返回函数终止时不再存在的内存单元引用。通过传递引用而不是整个数据对象，可以提供程序的运行速度。

	<img src="/images/ref.png">

	注意在返回值加上const，意味着不能使用返回的引用直接修改它指向的引用。参数类型为ostream &的函数可以接受ostream对象或声明的ofstream对象作为参数，见[文件类](https://github.com/nephen/cPrimerPlus/tree/master/chapter8/filefunc.cpp)。设置类如下

	<img src="/images/setf.png">

	指导原则：

	<img src="/images/guide.png">
- 默认参数指的是当函数调用中省略了实参时，自动使用的一个值。方法只是将值赋给原型中的参数。如

	```c
	char * left(const char * str, int n = 1);
	```
	对于带参数列表的函数，必须从右向左添加默认值。实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。[<例子>](https://github.com/nephen/cPrimerPlus/tree/master/chapter8/left.cpp)
- 函数重载的关键是函数的参数列表---也称为函数特征标。注意，类型引用和类型本身视为同一个特征标。匹配函数时，并不区分const和非const变量。对于函数重载，C++内部进行了名称修饰。[<例子>](https://github.com/nephen/cPrimerPlus/tree/master/chapter8/leftover.cpp)
- C++函数模板允许以任意类型的方式来定义函数。例如，建立一个交换模板。这样使生成的函数定义更简单、可靠。[<例子>](https://github.com/nephen/cPrimerPlus/tree/master/chapter8/funtemp.cpp)

	```c
	template <class Any>
	void Swap(Any &a, Any &b)
	{
		Any temp;
		temp = a;
		a = b;
		b = temp;
	}
	# => 或使用typename代替class
	```
	另外，模板也能进行重载。如void Swap(Any [], Any [], int)，并非所有的模板参数都必须为模板参数类型。[<例子>](https://github.com/nephen/cPrimerPlus/tree/master/chapter8/twotemps.cpp)
- 显示具体化的原型和定义应以template<>打头，并通过名称来指出类型，这样可以只交换结构体中的一部分成员。不要使用Swap()模板来生成函数定义，而应使用独立的、专门的函数显式的为job类型生成函数定义，如template <> void Swap<job>(job&, job&);，其中Swap<job>中的<job>是可选的。[<例子>](https://github.com/nephen/cPrimerPlus/tree/master/chapter8/twoswap.cpp)
- 编译器使用模板为特地类型生成函数定义时，得到的是模板实例，有隐式实例化和显式实例化。显式实例化如template void Swap<int>(int, int);，它与显式具体化不同，template后面没有<>。而隐式实例化指的是一般的模板调用。`警告`：试图在同一编程单元中使用同一类型的显式实例和显式具体化将出错。
- 隐式实例化、显式实例化和显式具体化统称为具体化，它们都使用具体类型的函数调用，而不是通用描述。
- 在重载解析中，哪一种执行的转换最少，将被优先得到执行。如果出现多个匹配或没有，都将出现错误。[<例子>](https://github.com/nephen/cPrimerPlus/tree/master/chapter8/temptempover.cpp)
