---
layout: post
title:  "初识NuttX操作系统"
categories: "drons_lifes"
author: nephne
tags: 工作生活
comments: true
---
这篇文章主要记录学习NuttX的过程以及对NuttX的理解。

1.0 NuttX Operating System User's Manual
============

[NuttX Operating System User's Manual](http://nuttx.org/doku.php?id=documentation:userguide)从软件开发者的视角为NuttX提供一般的使用信息。

<!--more-->
2.0 NSH 启动脚本------<i>翻译自[NuttX文档](http://nuttx.org/doku.php?id=documentation:nuttshell)，欢迎提出宝贵意见</i>
============

**NSH 启动脚本。**NSH支持选项来为NSH提供一个启动脚本。一般来说这种能力是用CONFIG_NSH_ROMFSETC启用，但有几个相关的描述NSH特定配置设置的配置选项。这种能力还取决于：

* CONFIG_DISABLE_MOUNTPOINT 未设置
* CONFIG_NFILE_DESCRIPTORS > 4
* CONFIG_FS_ROMFS 使能

**默认启动行为。**所提供的实施旨在为启动文件的使用提供极大的灵活性。本段将讨论所有配置选项设置为默认值时的一般行为。


在默认情况下，使能CONFIG_NSH_ROMFSETC将导致NSH在启动时表现如下：

* NSH将创建一个只读的内存盘（ROM盘），含有一个微小的romfs文件系统包含以下：

				`--init.d/
				     `-- rcS
rcS是NSH启动脚本。

* NSH将装入romfs文件系统到/etc，导致：

				|--dev/
				|   `-- ram0
				`--etc/
				    `--init.d/
				        `-- rcS

* 默认情况下，rcS脚本的内容：

				# Create a RAMDISK and mount it at XXXRDMOUNTPOINTXXX

				mkrd -m 1 -s 512 1024
				mkfatfs /dev/ram1
				mount -t vfat /dev/ram1 /tmp

* NSH将在/etc/init.d/rcS启动时执行脚本(在第一个NSH提示前)。脚本执行后，根文件将看起来像：

				|--dev/
				|   |-- ram0
				|   `-- ram1
				|--etc/
				|   `--init.d/
				|       `-- rcS
				`--tmp/

**修改ROMFS镜像。**/etc目录的内容保留在文件apps/nshlib/nsh_romfsimg.h里，或者如果include/arch/board/rcs.template定义了CONFIG_NSH_ARCHROMFS。为了修改启动行为，有三件事情要学习：

1.**配置选项**。和其他config_nsh_romfsetc 脚本NSH特定配置设置讨论的额外的配置选项。

2.**tools/mkromfsing.sh脚本**。脚本tools/mkromfsing.sh创建nsh_romfsing.h。不自动执行。如果你想改变创建和安装/tmp目录相关的配置设置，则必须使用tools/ mkromfsimg.sh脚本重新生成该头文件。
这个脚本的行为取决于三件事：

- 配置设置然后安装配置。
- genromfs工具，可从[http://romfs.sourceforge.net](http://romfs.sourceforge.net)下载。
- 文件apps/nshlib/rcS.template，或者如果include/arch/board/rcs.template定义了CONFIG_NSH_ARCHROMFS。

3.**rcS.template**。 apps/nshlib/rcS.template文件包含一般形式的rcS文件，配置的值插入到该模板文件来产生最终的RCS文件。

**注意**：apps/nshlib/rcs.template生成标准的默认nsh_romfsimg.h文件，如果CONFIG_NSH_ARCHROMFS在NuttX配置文件中定义，那么一个自定义、板级相关的驻留在configs/\<board>/include里的nsh_romfsimg.h文件将被使用。注意：当操作系统配置完成，include/arch/board将被链接到configs/\<board>/include。

所有的启动行为都包含在rcS.template。mkromfsimg.sh的作用是将特定的配置设置rcS.template来创建最终的rcS，以及生成包含ROMFS系统映像的头文件nsh_romfsimg.h。

3.0 定制NuttShell------<i>翻译自[NuttX文档](http://nuttx.org/doku.php?id=documentation:nuttshell)，欢迎提出宝贵意见</i>
============

`概要`。NuttShell (NSH)是一个简单的可用于NuttX的shell程序。它支持多种命令，是（非常）松散基于bash shell和用于unix shell编程的常用工具。本附录的段落将专注于定制NSH：添加新命令，改变初始化序列，等等。

####3.1 NSH 库和NSH 初始化

`概要`。NSH是一个库，可以在apps/nshlib发现实现。作为一个库，它可以定制成任何遵循以下描述的NSH初始化序列中的应用。作为一个例子，在 apps/examples/nsh/nsh_main.c在的代码说明如何启动NSH和逻辑也适用于您自己的自定义代码。虽然代码生成简单的作为一个例子，在大多数人只是用这个例子的代码作为应用main()功能。在下面的段落中讨论了这个例子的初始化。

**3.1.1 NSH初始化序列**

NSH启动顺序很简单。作为一个例子，apps/examples/nsh/nsh_main.c的代码说明如何启动NSH。简单工作如下：

1. 如果你有C++静态初始化器，它将调用up_cxxinitialize()的执行，这个函数将依次调用这些静态初始化器。在对STM3240G-EVAL板的情况下，对up_cxxinitialize()的实施可以在nuttx/configs/stm3240g-eval/src/up_cxxinitialize.c中发现。
2. 这个函数，然后调用nsh_initialize()，它将初始化NSH库，nsh_initialize()将具体描述如下。
3. 如果Telnetconsole启用，它调用驻留在NSH库里的nsh_telnetstart()。nsh_telnetstart()将启动telnet守护进程来监听Telnet连接和启动远程NSH会话。
4. 如果一个本地控制台启用（可能在一个串行端口），然后nsh_consolemain()将被调用。nsh_consolemain()也位于NSH库。nsh_consolemain()不返回，完成整个NSH初始化序列。

**3.1.2 nsh_initialize()**

NSH初始化函数，nsh_initialize()，在apps/nshlib/nsh_init.c发现。它也只有三件事：

1.*nsh_romfsetc()*:如果是这样的配置，它执行一个NSH启动脚本，它可以在目标文件系统/etc/init.d/rcS中发现。nsh_romfsetc()函数可以在apps/nshlib/nsh_romfsetc.c中发现。这个函数将一个ROMFS文件系统登记，然后安装ROMFS文件系统。/etc是只读、ROMFS文件系统通过nsh_romfsetc()安装的默认位置。

ROMFS镜像本身，也建成固件。默认情况下，该RCS启动脚本中包含以下逻辑：

		# Create a RAMDISK and mount it at XXXRDMOUNTPOINTXXX

		mkrd -m XXXMKRDMINORXXX -s XXMKRDSECTORSIZEXXX XXMKRDBLOCKSXXX
		mkfatfs /dev/ramXXXMKRDMINORXXX
		mount -t vfat /dev/ramXXXMKRDMINORXXX XXXRDMOUNTPOINTXXX

ROMFS镜像被创建时模板中的XXXX*XXXX字符得到替换：

* XXXMKRDMINORXXX 将成为RAM的次设备号。默认：0
* XXMKRDSECTORSIZEXXX 将成为内存设备扇区大小
* XXMKRDBLOCKSXXX 将成为该设备的扇区数
* XXXRDMOUNTPOINTXXX 将成为配置的安装点。默认值：/etc

默认情况下，替换的值将产生一个RCS文件如：

		# Create a RAMDISK and mount it at /tmp

		mkrd -m 1 -s 512 1024
		mkfatfs /dev/ram1
		mount -t vfat /dev/ram1 /tmp

然后：

* 在/dev/ram1创建一个大小为512 * 1024字节的RAMDISK，
* 在磁盘 /dev/ram1格式化FAT文件系统，然后
* 挂载FAT文件系统在配置挂载点，/tmp。

rcS模板文件能在apps/nshlib/rcS.template找到。由此产生的ROMFS文件系统可以在apps/nshlib/nsh_romfsimg.h发现。

2.*board_app_initialize()*：未来的任何特定于体系结构的NSH初始化将被执行（如果有）。如STM3240G-EVAL，这种特定结构的初始化可以在configs/stm3240g-eval/src/up_nsh.c配置。这也像：（1）初始化SPI设备，（2）初始化SDIO，和（3）安装，可以插入的任何SD卡。

3.*nsh_netinit()*：nsh_netinit()函数可以在apps/nshlib/nsh_netinit.c中发现。

####3.2 NSH命令

`概要`。NSH支持多种命令，是NSH程序的一部分。所有的NSH命令都列在上面的NSH文档里。然而，并不是所有这些命令都可以在任何时候使用。许多命令取决于某些NuttX配置选项。你可以输入命令help在NSH提示后看到实际可用的命令：

		nsh> help

例如，如果网络不支持，那么所有的网络相关的命令将从'nsh> help'展现的命令列表中消失。

**3.2.1 添加新的NSH命令**

新的命令可以非常容易地增加到NSH。你只需增加2件事：

1. 实现您的命令，和
2. NSH命令表中一个新的条目

`实现您的命令`。例如，如果你想添加一个新的叫mycmd命令到NSH，你会先在函数原型实现mycmd代码：

		int cmd_mycmd(FAR struct nsh_vtbl_s *vtbl, int argc, char **argv);

argc和argv是用来传递命令行参数到NSH命令。命令行参数是在一个非常标准的方式传递：argv [ 0 ]将该命令的名称，argv[1] 到 argv[argc-1]在NSH命令行提供额外的参数。

第一个参数，vtbl，是特殊的。这是一个指向特定会话状态信息的指针。你不需要知道状态信息的内容，但是当你与NSH的交互逻辑时你需要传递vtbl参数。你只需要利用vtbl参数来输出数据到控制台。你不用在NSH命令使用printf()，反而你会使用：

		void nsh_output(FAR struct nsh_vtbl_s *vtbl, const char *fmt, …); 

所以，如果你只想在控制台上输出“Hello, World!”，然后你的整个命令的执行可能是：

		int cmd_mycmd(FAR struct nsh_vtbl_s *vtbl, int argc, char **argv)
		{
		  nsh_output(vtbl, "e;Hello, World!"e;);
		  return 0;
		}

对新命令的原型应该放在apps/examples/nshlib/nsh.h。

`加入你命令到NSH命令表`。所有出现在单个表中支持NSH的命令都调用：

		const struct cmdmap_s g_cmdmap[]

该表可以在文件apps/examples/nshlib/nsh_parse.c中找到，结构cmdmap_s也是定义在apps/nshlib/nsh_parse.c中：

		struct cmdmap_s
		{
		  const char *cmd;        /* Name of the command */
		  cmd_t       handler;    /* Function that handles the command */
		  uint8_t     minargs;    /* Minimum number of arguments (including command) */
		  uint8_t     maxargs;    /* Maximum number of arguments (including command) */
		  const char *usage;      /* Usage instructions for 'help' command */
		};

这个结构提供了你需要的一切来描述你的命令：它的名字（CMD），处理命令的函数（cmd_mycmd()），命令需要的最大最小参数个数，和一个描述命令行参数字符串，最后一个字符串是输入"nsh> help"打印出来的东西。

所以，对于你commnd样本，你可以添加下面到g_cmdmap [ ]表：

		{ "mycmd", cmd_mycmd, 1, 1, NULL },

这项特别简单因为mycmd是如此简单。在g_cmdmap [ ]看看其他的命令更为复杂的例子。

####3.3 NSH“内置”的应用

`概要`。除了属于NSH一部分的命令之外，外部程序也可以作为NSH执行的命令。由于历史的原因这些外部程序被称之为“内置”应用。这个术语有点混乱，因为如上所述的实际的NSH命令是真正内置到NSH的，而这些应用是外接到NuttX的。

它们可以通过在NSH提示简单地键入应用程序的名称执行，在这个意义上这些应用可以内置到NSH。内置的应用程序支持是启用这些配置选项：

+ 